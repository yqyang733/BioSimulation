ğŸ‘ è¯„ä»·å°åˆ†å­åŒ–åˆç‰©ç”Ÿæˆæ¨¡å‹çš„æŒ‡æ ‡

---
[TOC]

---
## Evaluation Metrics
### Validity
**Description:** the percentage of chemically valid molecules among all generated molecules.
**å…·ä½“æ“ä½œæ€è·¯ï¼š** å¯¹äºè®­ç»ƒå¥½çš„æ¨¡å‹ï¼Œå¯¹å…¶latent spaceè¿›è¡Œä¸€å®šæ¬¡æ•°çš„é‡‡æ ·å¹¶è§£ç æˆåˆ†å­ã€‚ç„¶åä½¿ç”¨RDKitåˆ¤æ–­ç”Ÿæˆçš„åˆ†å­çš„æ­£ç¡®æ€§ã€‚ç”¨RDKitè¯†åˆ«å‡ºæ¥çš„SMILESçš„ä¸ªæ•°ï¼ˆæ­£ç¡®çš„åˆ†å­çš„æ•°ç›®ï¼‰é™¤ä»¥é‡‡æ ·æ¬¡æ•°å°±æ˜¯æœ‰æ•ˆæ€§ã€‚
**ä»£ç ç¤ºä¾‹ï¼š**
```python
from rdkit.Chem import MolFromSmiles

def sample_latent_space(vae_encoder, vae_decoder, sample_len):
    vae_encoder.eval()
    vae_decoder.eval()

    gathered_atoms = []

    fancy_latent_point = torch.randn(1, 1, vae_encoder.latent_dimension,
                                     device=device)
    hidden = vae_decoder.init_hidden()

    # runs over letters from molecules (len=size of largest molecule)
    for _ in range(sample_len):
        out_one_hot, hidden = vae_decoder(fancy_latent_point, hidden)

        out_one_hot = out_one_hot.flatten().detach()
        soft = nn.Softmax(0)
        out_one_hot = soft(out_one_hot)

        out_index = out_one_hot.argmax(0)
        gathered_atoms.append(out_index.data.cpu().tolist())

    vae_encoder.train()
    vae_decoder.train()

    return gathered_atoms

def is_correct_smiles(smiles):
    """
    Using RDKit to calculate whether molecule is syntactically and
    semantically valid.
    """
    if smiles == "":
        return False

    try:
        return MolFromSmiles(smiles, sanitize=True) is not None
    except Exception:
        return False

def latent_space_quality(vae_encoder, vae_decoder, type_of_encoding,
                         alphabet, sample_num, sample_len):
    total_correct = 0
    all_correct_molecules = set()
    print(f"latent_space_quality:"
          f" Take {sample_num} samples from the latent space")

    for _ in range(1, sample_num + 1):

        molecule_pre = ''
        for i in sample_latent_space(vae_encoder, vae_decoder, sample_len):
            molecule_pre += alphabet[i]
        molecule = molecule_pre.replace(' ', '')

        if type_of_encoding == 1: 
            molecule = sf.decoder(molecule)

        if is_correct_smiles(molecule):
            total_correct += 1
            all_correct_molecules.add(molecule)

    return total_correct, len(all_correct_molecules)

validity, diversity  = latent_space_quality(vae_encoder, vae_decoder, type_of_encoding, alphabet,  sample_num, sample_len)
validity = validity * 100. / sample_num
diversity = diversity * 100. / sample_num
```

### Diversity or Uniqueness
**Description:** the percentage of unique valid molecules out of all generated molecules.
**ä»£ç ï¼š**
å¦‚ä¸Š**Validity**ä¸­æ‰€ç¤ºã€‚

### Reconstruction
**Description:** the percentage of the molecules that can be reconstructed from their own latent vectors.
**å…·ä½“æ“ä½œæ€è·¯ï¼š** å°†è¾“å…¥çš„SMILESæ¯ä¸ªå­—ç¬¦ä¸ç”Ÿæˆçš„SMILESæ¯ä¸ªå­—ç¬¦è¿›è¡Œé€ä¸€å¯¹æ¯”ï¼Œä½¿ç”¨ç›¸åŒçš„å­—ç¬¦æ•°ç›®é™¤ä»¥æ€»çš„è¾“å…¥çš„å­—ç¬¦æ•°ç›®ã€‚
**ä»£ç ç¤ºä¾‹ï¼š**
```python
def compute_recon_quality(x, x_hat):
    x_indices = x.reshape(-1, x.shape[2]).argmax(1)
    x_hat_indices = x_hat.reshape(-1, x_hat.shape[2]).argmax(1)

    differences = 1. - torch.abs(x_hat_indices - x_indices)
    differences = torch.clamp(differences, min=0., max=1.).double()
    quality = 100. * torch.mean(differences)
    quality = quality.detach().cpu().numpy()

    return quality
```
```python
def seqs_equal(seqs1, seqs2):
    return [torch.eq(s1, s2).all() for s1, s2 in zip(seqs1, seqs2)]
```
